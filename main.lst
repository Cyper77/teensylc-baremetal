
main.elf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <_VectorsFlash>:
   0:	00 18 00 20 c1 00 00 00 c7 04 00 00 c5 04 00 00     ... ............
  10:	c5 04 00 00 c5 04 00 00 c5 04 00 00 c5 04 00 00     ................
  20:	c5 04 00 00 c5 04 00 00 c5 04 00 00 c7 04 00 00     ................
  30:	c7 04 00 00 c5 04 00 00 c7 04 00 00 c7 04 00 00     ................
  40:	c7 04 00 00 c7 04 00 00 c7 04 00 00 c7 04 00 00     ................
  50:	c7 04 00 00 c7 04 00 00 c7 04 00 00 c7 04 00 00     ................
  60:	c7 04 00 00 c7 04 00 00 c7 04 00 00 c7 04 00 00     ................
  70:	c7 04 00 00 c7 04 00 00 c7 04 00 00 c7 04 00 00     ................
  80:	c7 04 00 00 c7 04 00 00 c7 04 00 00 c7 04 00 00     ................
  90:	c7 04 00 00 c7 04 00 00 c7 04 00 00 c7 04 00 00     ................
  a0:	c7 04 00 00 c7 04 00 00 c7 04 00 00 c7 04 00 00     ................
  b0:	c7 04 00 00 c7 04 00 00 c7 04 00 00 c7 04 00 00     ................

000000c0 <ResetHandler>:
__attribute__ ((optimize("-Os")))
#else
__attribute__ ((section(".startup"),optimize("-Os")))
#endif
void ResetHandler(void)
{
  c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile ("nop");
	__asm__ volatile ("nop");
#endif
	// programs using the watchdog timer or needing to initialize hardware as
	// early as possible can implement startup_early_hook()
	startup_early_hook();
  c2:	f000 fa1f 	bl	504 <startup_early_hook>
		RTC_SR = 0;
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif
	// release I/O pins hold, if we woke up from VLLS mode
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
  c6:	2108      	movs	r1, #8
  c8:	4b40      	ldr	r3, [pc, #256]	; (1cc <ResetHandler+0x10c>)
  ca:	781a      	ldrb	r2, [r3, #0]
  cc:	420a      	tst	r2, r1
  ce:	d002      	beq.n	d6 <ResetHandler+0x16>
  d0:	781a      	ldrb	r2, [r3, #0]
  d2:	430a      	orrs	r2, r1
  d4:	701a      	strb	r2, [r3, #0]
    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
  d6:	222a      	movs	r2, #42	; 0x2a
  d8:	4b3d      	ldr	r3, [pc, #244]	; (1d0 <ResetHandler+0x110>)
  da:	483e      	ldr	r0, [pc, #248]	; (1d4 <ResetHandler+0x114>)
  dc:	701a      	strb	r2, [r3, #0]
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
  de:	2300      	movs	r3, #0
  e0:	493d      	ldr	r1, [pc, #244]	; (1d8 <ResetHandler+0x118>)
  e2:	4c3e      	ldr	r4, [pc, #248]	; (1dc <ResetHandler+0x11c>)
  e4:	181a      	adds	r2, r3, r0
  e6:	428a      	cmp	r2, r1
  e8:	d203      	bcs.n	f2 <ResetHandler+0x32>
  ea:	58e5      	ldr	r5, [r4, r3]
  ec:	3304      	adds	r3, #4
  ee:	6015      	str	r5, [r2, #0]
  f0:	e7f8      	b.n	e4 <ResetHandler+0x24>
  f2:	2100      	movs	r1, #0
  f4:	4b3a      	ldr	r3, [pc, #232]	; (1e0 <ResetHandler+0x120>)
	dest = &_sbss;
	while (dest < &_ebss) *dest++ = 0;
  f6:	4a3b      	ldr	r2, [pc, #236]	; (1e4 <ResetHandler+0x124>)
  f8:	4293      	cmp	r3, r2
  fa:	d201      	bcs.n	100 <ResetHandler+0x40>
  fc:	c302      	stmia	r3!, {r1}
  fe:	e7fb      	b.n	f8 <ResetHandler+0x38>
 100:	2300      	movs	r3, #0

	// default all interrupts to medium priority level
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = _VectorsFlash[i];
 102:	4a39      	ldr	r2, [pc, #228]	; (1e8 <ResetHandler+0x128>)
 104:	4939      	ldr	r1, [pc, #228]	; (1ec <ResetHandler+0x12c>)
 106:	5858      	ldr	r0, [r3, r1]
 108:	4694      	mov	ip, r2
 10a:	5098      	str	r0, [r3, r2]
 10c:	3304      	adds	r3, #4
 10e:	2bc0      	cmp	r3, #192	; 0xc0
 110:	d1f9      	bne.n	106 <ResetHandler+0x46>
 112:	2100      	movs	r1, #0
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
 114:	2603      	movs	r6, #3
 116:	25ff      	movs	r5, #255	; 0xff
 118:	2480      	movs	r4, #128	; 0x80
 11a:	088a      	lsrs	r2, r1, #2
 11c:	4b34      	ldr	r3, [pc, #208]	; (1f0 <ResetHandler+0x130>)
 11e:	0092      	lsls	r2, r2, #2
 120:	18d2      	adds	r2, r2, r3
 122:	1c0b      	adds	r3, r1, #0
 124:	1c2f      	adds	r7, r5, #0
 126:	4033      	ands	r3, r6
 128:	00db      	lsls	r3, r3, #3
 12a:	409f      	lsls	r7, r3
 12c:	6810      	ldr	r0, [r2, #0]
 12e:	3101      	adds	r1, #1
 130:	43b8      	bics	r0, r7
 132:	1c07      	adds	r7, r0, #0
 134:	1c20      	adds	r0, r4, #0
 136:	4098      	lsls	r0, r3
 138:	1c03      	adds	r3, r0, #0
 13a:	433b      	orrs	r3, r7
 13c:	6013      	str	r3, [r2, #0]
 13e:	2920      	cmp	r1, #32
 140:	d1eb      	bne.n	11a <ResetHandler+0x5a>
	SCB_VTOR = (uint32_t)_VectorsRam;	// use vector table in RAM
 142:	4662      	mov	r2, ip
 144:	4b2b      	ldr	r3, [pc, #172]	; (1f4 <ResetHandler+0x134>)
 146:	601a      	str	r2, [r3, #0]
    #if defined(KINETISK)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
    #elif defined(KINETISL)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
 148:	228a      	movs	r2, #138	; 0x8a
 14a:	4b2b      	ldr	r3, [pc, #172]	; (1f8 <ResetHandler+0x138>)
 14c:	701a      	strb	r2, [r3, #0]
    #endif
	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;
 14e:	4b2b      	ldr	r3, [pc, #172]	; (1fc <ResetHandler+0x13c>)
 150:	3a66      	subs	r2, #102	; 0x66
 152:	705a      	strb	r2, [r3, #1]
	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);
 154:	327c      	adds	r2, #124	; 0x7c
 156:	701a      	strb	r2, [r3, #0]
	// wait for crystal oscillator to begin
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
 158:	3a9e      	subs	r2, #158	; 0x9e
 15a:	7999      	ldrb	r1, [r3, #6]
 15c:	4211      	tst	r1, r2
 15e:	d0fc      	beq.n	15a <ResetHandler+0x9a>
	// wait for FLL to use oscillator
	while ((MCG_S & MCG_S_IREFST) != 0) ;
 160:	2210      	movs	r2, #16
 162:	7999      	ldrb	r1, [r3, #6]
 164:	4211      	tst	r1, r2
 166:	d1fc      	bne.n	162 <ResetHandler+0xa2>
	// wait for MCGOUT to use oscillator
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
 168:	200c      	movs	r0, #12
 16a:	799a      	ldrb	r2, [r3, #6]
 16c:	4923      	ldr	r1, [pc, #140]	; (1fc <ResetHandler+0x13c>)
 16e:	4002      	ands	r2, r0
 170:	2a08      	cmp	r2, #8
 172:	d1fa      	bne.n	16a <ResetHandler+0xaa>
    #endif
   #else
    #if F_CPU == 72000000
	MCG_C5 = MCG_C5_PRDIV0(5);		 // config PLL input for 16 MHz Crystal / 6 = 2.667 Hz
    #else
	MCG_C5 = MCG_C5_PRDIV0(3);		 // config PLL input for 16 MHz Crystal / 4 = 4 MHz
 174:	3a05      	subs	r2, #5
 176:	710a      	strb	r2, [r1, #4]
    #elif F_CPU == 120000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(6); // config PLL for 120 MHz output
    #elif F_CPU == 72000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(3); // config PLL for 72 MHz output
    #elif F_CPU == 96000000 || F_CPU == 48000000 || F_CPU == 24000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(0); // config PLL for 96 MHz output
 178:	323d      	adds	r2, #61	; 0x3d
 17a:	714a      	strb	r2, [r1, #5]
    #error "This clock speed isn't supported..."
    #endif
   #endif

	// wait for PLL to start using xtal as its input
	while (!(MCG_S & MCG_S_PLLST)) ;
 17c:	3a20      	subs	r2, #32
 17e:	7999      	ldrb	r1, [r3, #6]
 180:	4211      	tst	r1, r2
 182:	d0fc      	beq.n	17e <ResetHandler+0xbe>
	// wait for PLL to lock
	while (!(MCG_S & MCG_S_LOCK0)) ;
 184:	2240      	movs	r2, #64	; 0x40
 186:	7999      	ldrb	r1, [r3, #6]
 188:	4211      	tst	r1, r2
 18a:	d0fc      	beq.n	186 <ResetHandler+0xc6>
	// config divisors: 48 MHz core, 48 MHz bus, 24 MHz flash, USB = 96 / 2
  #if defined(KINETISK)
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(1) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV3(1) |  SIM_CLKDIV1_OUTDIV4(3);
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(1);
  #elif defined(KINETISL)
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(1) | SIM_CLKDIV1_OUTDIV4(1);
 18c:	491c      	ldr	r1, [pc, #112]	; (200 <ResetHandler+0x140>)
 18e:	4a1d      	ldr	r2, [pc, #116]	; (204 <ResetHandler+0x144>)
 190:	6011      	str	r1, [r2, #0]
#error "Error, F_CPU must be 192, 180, 168, 144, 120, 96, 72, 48, 24, 16, 8, 4, or 2 MHz"
#endif

#if F_CPU > 16000000
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
 192:	2120      	movs	r1, #32
 194:	4a19      	ldr	r2, [pc, #100]	; (1fc <ResetHandler+0x13c>)
 196:	7011      	strb	r1, [r2, #0]
	// wait for PLL clock to be used
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
 198:	3914      	subs	r1, #20
 19a:	799a      	ldrb	r2, [r3, #6]
 19c:	400a      	ands	r2, r1
 19e:	2a0c      	cmp	r2, #12
 1a0:	d1fb      	bne.n	19a <ResetHandler+0xda>
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_IRC48SEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
	#else
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
	#endif
	#elif defined(KINETISL)
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_CLKOUTSEL(6)
 1a2:	4a19      	ldr	r2, [pc, #100]	; (208 <ResetHandler+0x148>)
 1a4:	4b19      	ldr	r3, [pc, #100]	; (20c <ResetHandler+0x14c>)
 1a6:	601a      	str	r2, [r3, #0]
    // since we are not going into "stop mode" i removed it
	SMC_PMCTRL = SMC_PMCTRL_RUNM(2); // VLPR mode :-)
#endif

	// initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
 1a8:	4a19      	ldr	r2, [pc, #100]	; (210 <ResetHandler+0x150>)
 1aa:	4b1a      	ldr	r3, [pc, #104]	; (214 <ResetHandler+0x154>)
 1ac:	601a      	str	r2, [r3, #0]
	SYST_CVR = 0;
 1ae:	2200      	movs	r2, #0
 1b0:	4b19      	ldr	r3, [pc, #100]	; (218 <ResetHandler+0x158>)
 1b2:	601a      	str	r2, [r3, #0]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
 1b4:	4b19      	ldr	r3, [pc, #100]	; (21c <ResetHandler+0x15c>)
 1b6:	3207      	adds	r2, #7
 1b8:	601a      	str	r2, [r3, #0]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
 1ba:	4a19      	ldr	r2, [pc, #100]	; (220 <ResetHandler+0x160>)
 1bc:	4b19      	ldr	r3, [pc, #100]	; (224 <ResetHandler+0x164>)
 1be:	601a      	str	r2, [r3, #0]

	//init_pins();
	__enable_irq();
 1c0:	b662      	cpsie	i
	}
#endif

	// __libc_init_array();

	startup_late_hook();
 1c2:	f000 f9a5 	bl	510 <startup_late_hook>
	main();
 1c6:	f000 f9a5 	bl	514 <main>
}
 1ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 1cc:	4007d002 	.word	0x4007d002
 1d0:	4007e000 	.word	0x4007e000
 1d4:	1ffff8c0 	.word	0x1ffff8c0
 1d8:	1ffff8c0 	.word	0x1ffff8c0
 1dc:	0000055c 	.word	0x0000055c
 1e0:	1ffff8c0 	.word	0x1ffff8c0
 1e4:	1ffff8dc 	.word	0x1ffff8dc
 1e8:	1ffff800 	.word	0x1ffff800
 1ec:	00000000 	.word	0x00000000
 1f0:	e000e400 	.word	0xe000e400
 1f4:	e000ed08 	.word	0xe000ed08
 1f8:	40065000 	.word	0x40065000
 1fc:	40064000 	.word	0x40064000
 200:	10010000 	.word	0x10010000
 204:	40048044 	.word	0x40048044
 208:	050500c0 	.word	0x050500c0
 20c:	40048004 	.word	0x40048004
 210:	0000bb7f 	.word	0x0000bb7f
 214:	e000e014 	.word	0xe000e014
 218:	e000e018 	.word	0xe000e018
 21c:	e000e010 	.word	0xe000e010
 220:	20200000 	.word	0x20200000
 224:	e000ed20 	.word	0xe000ed20
 228:	ffffffff 	.word	0xffffffff
 22c:	ffffffff 	.word	0xffffffff
 230:	ffffffff 	.word	0xffffffff
 234:	ffffffff 	.word	0xffffffff
 238:	ffffffff 	.word	0xffffffff
 23c:	ffffffff 	.word	0xffffffff
 240:	ffffffff 	.word	0xffffffff
 244:	ffffffff 	.word	0xffffffff
 248:	ffffffff 	.word	0xffffffff
 24c:	ffffffff 	.word	0xffffffff
 250:	ffffffff 	.word	0xffffffff
 254:	ffffffff 	.word	0xffffffff
 258:	ffffffff 	.word	0xffffffff
 25c:	ffffffff 	.word	0xffffffff
 260:	ffffffff 	.word	0xffffffff
 264:	ffffffff 	.word	0xffffffff
 268:	ffffffff 	.word	0xffffffff
 26c:	ffffffff 	.word	0xffffffff
 270:	ffffffff 	.word	0xffffffff
 274:	ffffffff 	.word	0xffffffff
 278:	ffffffff 	.word	0xffffffff
 27c:	ffffffff 	.word	0xffffffff
 280:	ffffffff 	.word	0xffffffff
 284:	ffffffff 	.word	0xffffffff
 288:	ffffffff 	.word	0xffffffff
 28c:	ffffffff 	.word	0xffffffff
 290:	ffffffff 	.word	0xffffffff
 294:	ffffffff 	.word	0xffffffff
 298:	ffffffff 	.word	0xffffffff
 29c:	ffffffff 	.word	0xffffffff
 2a0:	ffffffff 	.word	0xffffffff
 2a4:	ffffffff 	.word	0xffffffff
 2a8:	ffffffff 	.word	0xffffffff
 2ac:	ffffffff 	.word	0xffffffff
 2b0:	ffffffff 	.word	0xffffffff
 2b4:	ffffffff 	.word	0xffffffff
 2b8:	ffffffff 	.word	0xffffffff
 2bc:	ffffffff 	.word	0xffffffff
 2c0:	ffffffff 	.word	0xffffffff
 2c4:	ffffffff 	.word	0xffffffff
 2c8:	ffffffff 	.word	0xffffffff
 2cc:	ffffffff 	.word	0xffffffff
 2d0:	ffffffff 	.word	0xffffffff
 2d4:	ffffffff 	.word	0xffffffff
 2d8:	ffffffff 	.word	0xffffffff
 2dc:	ffffffff 	.word	0xffffffff
 2e0:	ffffffff 	.word	0xffffffff
 2e4:	ffffffff 	.word	0xffffffff
 2e8:	ffffffff 	.word	0xffffffff
 2ec:	ffffffff 	.word	0xffffffff
 2f0:	ffffffff 	.word	0xffffffff
 2f4:	ffffffff 	.word	0xffffffff
 2f8:	ffffffff 	.word	0xffffffff
 2fc:	ffffffff 	.word	0xffffffff
 300:	ffffffff 	.word	0xffffffff
 304:	ffffffff 	.word	0xffffffff
 308:	ffffffff 	.word	0xffffffff
 30c:	ffffffff 	.word	0xffffffff
 310:	ffffffff 	.word	0xffffffff
 314:	ffffffff 	.word	0xffffffff
 318:	ffffffff 	.word	0xffffffff
 31c:	ffffffff 	.word	0xffffffff
 320:	ffffffff 	.word	0xffffffff
 324:	ffffffff 	.word	0xffffffff
 328:	ffffffff 	.word	0xffffffff
 32c:	ffffffff 	.word	0xffffffff
 330:	ffffffff 	.word	0xffffffff
 334:	ffffffff 	.word	0xffffffff
 338:	ffffffff 	.word	0xffffffff
 33c:	ffffffff 	.word	0xffffffff
 340:	ffffffff 	.word	0xffffffff
 344:	ffffffff 	.word	0xffffffff
 348:	ffffffff 	.word	0xffffffff
 34c:	ffffffff 	.word	0xffffffff
 350:	ffffffff 	.word	0xffffffff
 354:	ffffffff 	.word	0xffffffff
 358:	ffffffff 	.word	0xffffffff
 35c:	ffffffff 	.word	0xffffffff
 360:	ffffffff 	.word	0xffffffff
 364:	ffffffff 	.word	0xffffffff
 368:	ffffffff 	.word	0xffffffff
 36c:	ffffffff 	.word	0xffffffff
 370:	ffffffff 	.word	0xffffffff
 374:	ffffffff 	.word	0xffffffff
 378:	ffffffff 	.word	0xffffffff
 37c:	ffffffff 	.word	0xffffffff
 380:	ffffffff 	.word	0xffffffff
 384:	ffffffff 	.word	0xffffffff
 388:	ffffffff 	.word	0xffffffff
 38c:	ffffffff 	.word	0xffffffff
 390:	ffffffff 	.word	0xffffffff
 394:	ffffffff 	.word	0xffffffff
 398:	ffffffff 	.word	0xffffffff
 39c:	ffffffff 	.word	0xffffffff
 3a0:	ffffffff 	.word	0xffffffff
 3a4:	ffffffff 	.word	0xffffffff
 3a8:	ffffffff 	.word	0xffffffff
 3ac:	ffffffff 	.word	0xffffffff
 3b0:	ffffffff 	.word	0xffffffff
 3b4:	ffffffff 	.word	0xffffffff
 3b8:	ffffffff 	.word	0xffffffff
 3bc:	ffffffff 	.word	0xffffffff
 3c0:	ffffffff 	.word	0xffffffff
 3c4:	ffffffff 	.word	0xffffffff
 3c8:	ffffffff 	.word	0xffffffff
 3cc:	ffffffff 	.word	0xffffffff
 3d0:	ffffffff 	.word	0xffffffff
 3d4:	ffffffff 	.word	0xffffffff
 3d8:	ffffffff 	.word	0xffffffff
 3dc:	ffffffff 	.word	0xffffffff
 3e0:	ffffffff 	.word	0xffffffff
 3e4:	ffffffff 	.word	0xffffffff
 3e8:	ffffffff 	.word	0xffffffff
 3ec:	ffffffff 	.word	0xffffffff
 3f0:	ffffffff 	.word	0xffffffff
 3f4:	ffffffff 	.word	0xffffffff
 3f8:	ffffffff 	.word	0xffffffff
 3fc:	ffffffff 	.word	0xffffffff

00000400 <flashconfigbytes>:
 400:	ffffffff ffffffff ffffffff fffff9de     ................

00000410 <deregister_tm_clones>:
 410:	b508      	push	{r3, lr}
 412:	4b05      	ldr	r3, [pc, #20]	; (428 <deregister_tm_clones+0x18>)
 414:	4805      	ldr	r0, [pc, #20]	; (42c <deregister_tm_clones+0x1c>)
 416:	3303      	adds	r3, #3
 418:	1a1b      	subs	r3, r3, r0
 41a:	2b06      	cmp	r3, #6
 41c:	d903      	bls.n	426 <deregister_tm_clones+0x16>
 41e:	4b04      	ldr	r3, [pc, #16]	; (430 <deregister_tm_clones+0x20>)
 420:	2b00      	cmp	r3, #0
 422:	d000      	beq.n	426 <deregister_tm_clones+0x16>
 424:	4798      	blx	r3
 426:	bd08      	pop	{r3, pc}
 428:	1ffff8c0 	.word	0x1ffff8c0
 42c:	1ffff8c0 	.word	0x1ffff8c0
 430:	00000000 	.word	0x00000000

00000434 <register_tm_clones>:
 434:	4806      	ldr	r0, [pc, #24]	; (450 <register_tm_clones+0x1c>)
 436:	4907      	ldr	r1, [pc, #28]	; (454 <register_tm_clones+0x20>)
 438:	b508      	push	{r3, lr}
 43a:	1a09      	subs	r1, r1, r0
 43c:	1089      	asrs	r1, r1, #2
 43e:	0fcb      	lsrs	r3, r1, #31
 440:	1859      	adds	r1, r3, r1
 442:	1049      	asrs	r1, r1, #1
 444:	d003      	beq.n	44e <register_tm_clones+0x1a>
 446:	4b04      	ldr	r3, [pc, #16]	; (458 <register_tm_clones+0x24>)
 448:	2b00      	cmp	r3, #0
 44a:	d000      	beq.n	44e <register_tm_clones+0x1a>
 44c:	4798      	blx	r3
 44e:	bd08      	pop	{r3, pc}
 450:	1ffff8c0 	.word	0x1ffff8c0
 454:	1ffff8c0 	.word	0x1ffff8c0
 458:	00000000 	.word	0x00000000

0000045c <__do_global_dtors_aux>:
 45c:	b510      	push	{r4, lr}
 45e:	4c07      	ldr	r4, [pc, #28]	; (47c <__do_global_dtors_aux+0x20>)
 460:	7823      	ldrb	r3, [r4, #0]
 462:	2b00      	cmp	r3, #0
 464:	d109      	bne.n	47a <__do_global_dtors_aux+0x1e>
 466:	f7ff ffd3 	bl	410 <deregister_tm_clones>
 46a:	4b05      	ldr	r3, [pc, #20]	; (480 <__do_global_dtors_aux+0x24>)
 46c:	2b00      	cmp	r3, #0
 46e:	d002      	beq.n	476 <__do_global_dtors_aux+0x1a>
 470:	4804      	ldr	r0, [pc, #16]	; (484 <__do_global_dtors_aux+0x28>)
 472:	e000      	b.n	476 <__do_global_dtors_aux+0x1a>
 474:	bf00      	nop
 476:	2301      	movs	r3, #1
 478:	7023      	strb	r3, [r4, #0]
 47a:	bd10      	pop	{r4, pc}
 47c:	1ffff8c0 	.word	0x1ffff8c0
 480:	00000000 	.word	0x00000000
 484:	0000055c 	.word	0x0000055c

00000488 <frame_dummy>:
 488:	b508      	push	{r3, lr}
 48a:	4b09      	ldr	r3, [pc, #36]	; (4b0 <frame_dummy+0x28>)
 48c:	2b00      	cmp	r3, #0
 48e:	d003      	beq.n	498 <frame_dummy+0x10>
 490:	4808      	ldr	r0, [pc, #32]	; (4b4 <frame_dummy+0x2c>)
 492:	4909      	ldr	r1, [pc, #36]	; (4b8 <frame_dummy+0x30>)
 494:	e000      	b.n	498 <frame_dummy+0x10>
 496:	bf00      	nop
 498:	4808      	ldr	r0, [pc, #32]	; (4bc <frame_dummy+0x34>)
 49a:	6803      	ldr	r3, [r0, #0]
 49c:	2b00      	cmp	r3, #0
 49e:	d102      	bne.n	4a6 <frame_dummy+0x1e>
 4a0:	f7ff ffc8 	bl	434 <register_tm_clones>
 4a4:	bd08      	pop	{r3, pc}
 4a6:	4b06      	ldr	r3, [pc, #24]	; (4c0 <frame_dummy+0x38>)
 4a8:	2b00      	cmp	r3, #0
 4aa:	d0f9      	beq.n	4a0 <frame_dummy+0x18>
 4ac:	4798      	blx	r3
 4ae:	e7f7      	b.n	4a0 <frame_dummy+0x18>
 4b0:	00000000 	.word	0x00000000
 4b4:	0000055c 	.word	0x0000055c
 4b8:	1ffff8c4 	.word	0x1ffff8c4
 4bc:	1ffff8c0 	.word	0x1ffff8c0
 4c0:	00000000 	.word	0x00000000

000004c4 <fault_isr>:
    while (dest < dend) *(dest++) = 0;
}

void fault_isr(void)
{
	while (1) ;
 4c4:	e7fe      	b.n	4c4 <fault_isr>

000004c6 <unused_isr>:
}

void unused_isr(void)
{
 4c6:	e7fe      	b.n	4c6 <unused_isr>

000004c8 <init_data_bss>:
{
    unsigned int *src, *dest, *dend;
    src  = (unsigned int *)(&_etext);
    dest = (unsigned int *)(&_sdata);
    dend = (unsigned int *)(&_edata);
    while (dest < dend) *(dest++) = *(src++);
 4c8:	2200      	movs	r2, #0
 4ca:	4b09      	ldr	r3, [pc, #36]	; (4f0 <init_data_bss+0x28>)
 4cc:	4909      	ldr	r1, [pc, #36]	; (4f4 <init_data_bss+0x2c>)
 4ce:	18d3      	adds	r3, r2, r3
 4d0:	428b      	cmp	r3, r1
 4d2:	d204      	bcs.n	4de <init_data_bss+0x16>
 4d4:	4908      	ldr	r1, [pc, #32]	; (4f8 <init_data_bss+0x30>)
 4d6:	5889      	ldr	r1, [r1, r2]
 4d8:	3204      	adds	r2, #4
 4da:	6019      	str	r1, [r3, #0]
 4dc:	e7f5      	b.n	4ca <init_data_bss+0x2>
 4de:	4b07      	ldr	r3, [pc, #28]	; (4fc <init_data_bss+0x34>)
    dest = (unsigned int *)(&_sbss);
    dend = (unsigned int *)(&_ebss);
    while (dest < dend) *(dest++) = 0;
 4e0:	4a07      	ldr	r2, [pc, #28]	; (500 <init_data_bss+0x38>)
 4e2:	4293      	cmp	r3, r2
 4e4:	d202      	bcs.n	4ec <init_data_bss+0x24>
 4e6:	2200      	movs	r2, #0
 4e8:	c304      	stmia	r3!, {r2}
 4ea:	e7f9      	b.n	4e0 <init_data_bss+0x18>
}
 4ec:	4770      	bx	lr
 4ee:	46c0      	nop			; (mov r8, r8)
 4f0:	1ffff8c0 	.word	0x1ffff8c0
 4f4:	1ffff8c0 	.word	0x1ffff8c0
 4f8:	0000055c 	.word	0x0000055c
 4fc:	1ffff8c0 	.word	0x1ffff8c0
 500:	1ffff8dc 	.word	0x1ffff8dc

00000504 <startup_early_hook>:

static void startup_default_early_hook(void) {
#if defined(KINETISK)
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
#elif defined(KINETISL)
	SIM_COPC = 0;  // disable the watchdog
 504:	2200      	movs	r2, #0
 506:	4b01      	ldr	r3, [pc, #4]	; (50c <startup_early_hook+0x8>)
 508:	601a      	str	r2, [r3, #0]
#endif
}
 50a:	4770      	bx	lr
 50c:	40048100 	.word	0x40048100

00000510 <startup_late_hook>:
static void startup_default_late_hook(void) {}
 510:	4770      	bx	lr
 512:	46c0      	nop			; (mov r8, r8)

00000514 <main>:

#define LED  (1U << 5)

extern "C" int main(void)
{
    SIM_SCGC5 = SIM_SCGC5_PORTC;
 514:	2280      	movs	r2, #128	; 0x80
 516:	4b08      	ldr	r3, [pc, #32]	; (538 <main+0x24>)
 518:	0112      	lsls	r2, r2, #4
 51a:	601a      	str	r2, [r3, #0]
    PORTC_PCR5 = PORT_PCR_MUX(1U);
 51c:	2280      	movs	r2, #128	; 0x80
 51e:	4b07      	ldr	r3, [pc, #28]	; (53c <main+0x28>)
    GPIOC_PDDR |= LED;
 520:	4907      	ldr	r1, [pc, #28]	; (540 <main+0x2c>)
#define LED  (1U << 5)

extern "C" int main(void)
{
    SIM_SCGC5 = SIM_SCGC5_PORTC;
    PORTC_PCR5 = PORT_PCR_MUX(1U);
 522:	0052      	lsls	r2, r2, #1
 524:	601a      	str	r2, [r3, #0]
    GPIOC_PDDR |= LED;
 526:	680b      	ldr	r3, [r1, #0]
 528:	3ae0      	subs	r2, #224	; 0xe0
 52a:	4313      	orrs	r3, r2
 52c:	600b      	str	r3, [r1, #0]
    GPIOC_PSOR = LED;
 52e:	4b05      	ldr	r3, [pc, #20]	; (544 <main+0x30>)
}
 530:	2000      	movs	r0, #0
extern "C" int main(void)
{
    SIM_SCGC5 = SIM_SCGC5_PORTC;
    PORTC_PCR5 = PORT_PCR_MUX(1U);
    GPIOC_PDDR |= LED;
    GPIOC_PSOR = LED;
 532:	601a      	str	r2, [r3, #0]
}
 534:	4770      	bx	lr
 536:	46c0      	nop			; (mov r8, r8)
 538:	40048038 	.word	0x40048038
 53c:	4004b014 	.word	0x4004b014
 540:	400ff094 	.word	0x400ff094
 544:	400ff084 	.word	0x400ff084

00000548 <_init>:
 548:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 54a:	46c0      	nop			; (mov r8, r8)
 54c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 54e:	bc08      	pop	{r3}
 550:	469e      	mov	lr, r3
 552:	4770      	bx	lr

00000554 <__frame_dummy_init_array_entry>:
 554:	0489 0000                                   ....

Disassembly of section .fini:

00000558 <_fini>:
 558:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 55a:	46c0      	nop			; (mov r8, r8)
